# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.
# This file is compatible with both classic and new-style classes.

from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pymeanshift', [dirname(__file__)])
        except ImportError:
            import _pymeanshift
            return _pymeanshift
        if fp is not None:
            try:
                _mod = imp.load_module('_pymeanshift', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _pymeanshift = swig_import_helper()
    del swig_import_helper
else:
    import _pymeanshift
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0



def _segmentMeanShiftImpl(*args):
  return _pymeanshift._segmentMeanShiftImpl(*args)
_segmentMeanShiftImpl = _pymeanshift._segmentMeanShiftImpl
# Exceptions definition
class OpenCVNotFound(Exception):
  pass

class BadParameterValue(Exception):
  pass

class ImplementationError(Exception):
  pass

class BadImageType(Exception):
  pass


try:
  import cv
except:
  raise OpenCVNotFound("Cannot import OpenCV Python module.")


def segmentMeanShift(inputImage, sigmaS=6, sigmaR=4.5, minRegion=300, speedUpLevel=2):
  '''
  Segmentation of an image (grayscale or color) using the mean shift algorithm.
  
  Return a 3-tuple (colorLabelsImage, labelsImg, nbRegions).
    - colorLabelsImage is the segmented image with each region colored as the
      mean color value of its pixels.
    - labelsImg is an image where a pixel value represents the region it belongs to.
      This image is one channel, 32 bits per pixel.
    - nbRegions is the number of regions found in the image.

  This function can take CvMat or IplImage as an input image. Th output images will
  be of the same type than the input image. If IplImage is used, be aware that the
  output IplImage will not be aligned on memory boundary. This is not a problem
  as long as the OpenCV functions are used to read/write pixel values in these images.

  The mean shift algorithm and its implementation in C++ are by
  Chris M. Christoudias and Bogdan Georgescu. This Python module provides the "glue"
  that is necessary in order to use the C++ implementation with OpenCV in Python.

  For details on the algorithm:
  D. Comanicu, P. Meer: "Mean shift: A robust approach toward feature space analysis".
  IEEE Transactions on Pattern Analysis and Machine Intelligence, May 2002.
  
  '''

  if sigmaS < 0:
    raise BadParameterValue("Spatial radius must be greater or equal to zero")
  if sigmaR < 0:
    raise BadParameterValue("Range radius must be greater or equal to zero")
  if minRegion < 0:
    raise BadParameterValue("Minimum region must be greater or equal to zero")
  if speedUpLevel < 0 or speedUpLevel > 2:
    raise BadParameterValue("Speedup level must be 0 (no speedup), 1 (medium speedup), or 2 (high speedup)")

  if isinstance(inputImage, cv.cvmat):
    # If input image is a CvMat, then create outputs image as CvMat too      
    inputImageMat = inputImage
    colorImageMat = cv.CreateMat(inputImageMat.rows, inputImageMat.cols, inputImageMat.type)
    labelImageMat = cv.CreateMat(inputImageMat.rows, inputImageMat.cols, cv.CV_32SC1)
    colorImage = colorImageMat
    labelImage = labelImageMat
  elif isinstance(inputImage, cv.iplimage):
    # If input image is an IplImage, then create outputs image as IplImage too
    # Input image must be copied into a CvMat structure since IplImage
    # might be aligned on memory boundaries, which is a problem for the mean shift algorithm implementation
    inputImageMatTmp = cv.GetMat(inputImage)
    inputImageMat = cv.CreateMat(inputImageMatTmp.rows, inputImageMatTmp.cols, inputImageMatTmp.type)
    cv.Copy(inputImageMatTmp, inputImageMat)
    
    colorImageMat = cv.CreateMat(inputImageMat.rows, inputImageMat.cols, inputImageMat.type)
    labelImageMat = cv.CreateMat(inputImageMat.rows, inputImageMat.cols, cv.CV_32SC1)
    colorImage = cv.GetImage(colorImageMat)
    labelImage = cv.GetImage(labelImageMat)
  else:
    raise BadImageType("Input image must be either a CvMat or an IplImage")
  
  nbRegion = _segmentMeanShiftImpl(inputImageMat, colorImageMat, labelImageMat, sigmaS, sigmaR, minRegion, speedUpLevel)

  if nbRegion < 0:
    raise ImplementationError("An error occured in the mean shift C implementation (This should not happen)")

  return (colorImage, labelImage, nbRegion)




